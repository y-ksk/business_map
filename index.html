<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>シナジーマップ（俯瞰＋ズーム&ドラッグ対応・安全版）</title>

    <!-- 見た目用：Tailwind（CDN） -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React + ReactDOM（CDN） -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- JSXをブラウザで解釈するためのBabel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      html, body, #root { height: 100%; }
      body { background: #f1f5f9; } /* slate-100 */
      /* Notion埋め込み対策：埋め込み枠が小さくても操作しやすいよう確保 */
      .viewport { height: 92vh; }
      /* テキスト選択でドラッグが途切れないように */
      .no-select { user-select: none; -webkit-user-select: none; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useRef, useState } = React;

      /* ========== 小ユーティリティ ========== */
      const cx = (...cls) => cls.filter(Boolean).join(" ");

      /* ========== グリッド（重なり防止の俯瞰配置） ========== */
      const GRID = { COLS: 5, ROWS: 7, MARGIN: 3 }; // %余白
      const gridToPercent = (col, row) => {
        const left = GRID.MARGIN + (col * (100 - GRID.MARGIN * 2)) / (GRID.COLS - 1);
        const top  = GRID.MARGIN + (row * (100 - GRID.MARGIN * 2)) / (GRID.ROWS - 1);
        return { left, top };
      };

      /* ========== データ ========== */
      const nodes = [
        { id: "core", title: "中核コンテンツ", subtitle: "『カルチャーフィットを科学する』世界観",
          points: ["価値観のミスマッチをなくす","採用＝カルチャー×スキルの適合","現場データ×AIで意思決定を客観化"],
          grid: { col: 0, row: 0 }, tone: "indigo" },
        { id: "entry", title: "入口（フロント）", subtitle: "無料/低単価で世界観に触れる接点",
          points: ["ブログ/Voicy/登壇/ケース公開","無料『採用診断ライト』","スカウト文テンプレ配布"],
          grid: { col: 0, row: 3 }, tone: "emerald" },
        { id: "p1", title: "Phase 1: 採用コミットジム", subtitle: "伴走コンサル（月額リテイナー）",
          points: ["採用戦略/面接官トレ/広報の内製化","キャッシュ創出（初期投資ほぼゼロ）","真の課題/成功パターンの一次データ"],
          grid: { col: 1, row: 3 }, tone: "cyan" },
        { id: "datalake", title: "データ基盤（行動×成功データ）", subtitle: "勝ち筋の学習・評価",
          points: ["求人要件×スカウト文×返信率","候補者属性×選考通過率","価値観指標×オンボ成功/離職"],
          grid: { col: 2, row: 3 }, tone: "slate" },
        { id: "p2", title: "Phase 2: AI Scout Analyst", subtitle: "スカウト文自動生成SaaS",
          points: ["1通30分→3分","品質の標準化とABテスト","MRR拡大＆スケール"],
          grid: { col: 3, row: 1 }, tone: "sky" },
        { id: "p3", title: "Phase 3: Culture Fit AI", subtitle: "価値観×文化の適合を測る診断",
          points: ["企業の生きた文化を言語化/可視化","候補者の価値観/潜在特性の測定","適合度スコア→配属/定着に活用"],
          grid: { col: 3, row: 5 }, tone: "violet" },
        { id: "brand", title: "雇用主ブランディング", subtitle: "語れる組織の物語/原体験の蓄積",
          points: ["採用広報資産（動画/記事/ノウハウ）","カルチャーデック/バリュー事例","次の候補者体験の燃料"],
          grid: { col: 4, row: 2 }, tone: "rose" },
        { id: "community", title: "コミュニティ（HRギルド）", subtitle: "卒業企業/採用担当の学習・共創の場",
          points: ["事例共有と共同検証（RWE）","プロモーター化（口コミ/紹介/登壇）","PoC参加・クラファン的支援"],
          grid: { col: 4, row: 5 }, tone: "amber" },
      ];

      const edges = [
        { from: "entry", to: "p1", label: "見込み→伴走", tone: "emerald" },
        { from: "p1", to: "datalake", label: "現場データ蓄積", tone: "cyan" },
        { from: "datalake", to: "p2", label: "学習→自動化", tone: "slate" },
        { from: "p2", to: "datalake", label: "AB結果/返信率フィードバック", tone: "sky" },
        { from: "datalake", to: "p3", label: "価値観モデルの精緻化", tone: "slate" },
        { from: "p3", to: "brand", label: "成功体験→物語化", tone: "violet" },
        { from: "brand", to: "entry", label: "物語が入口を拡張", tone: "rose" },
        { from: "p1", to: "community", label: "卒業/仲間化", tone: "cyan" },
        { from: "p2", to: "community", label: "ユーザー会/改善共創", tone: "sky" },
        { from: "p3", to: "community", label: "価値観診断の普及/検証", tone: "violet" },
        { from: "community", to: "entry", label: "口コミ/登壇/紹介", tone: "amber" },
        { from: "community", to: "datalake", label: "事例/失敗もデータ化", tone: "amber" },
        { from: "core", to: "entry", label: "思想の翻訳/発信", tone: "indigo" },
        { from: "core", to: "p1", label: "支援方針/型化の指針", tone: "indigo" },
        { from: "core", to: "p3", label: "価値観モデルの要件定義", tone: "indigo" },
      ];

      const toneToRing = {
        indigo: "ring-indigo-400", emerald: "ring-emerald-400", cyan: "ring-cyan-400",
        sky: "ring-sky-400", slate: "ring-slate-400", violet: "ring-violet-400",
        amber: "ring-amber-400", rose: "ring-rose-400",
      };
      const toneToStroke = {
        indigo: "#818cf8", emerald: "#34d399", cyan: "#22d3ee", sky: "#38bdf8",
        slate: "#94a3b8", violet: "#a78bfa", amber: "#f59e0b", rose: "#fb7185",
      };

      /* ========== 矢印のためのノード位置測定 ========== */
      function useNodePositions(containerRef) {
        const refs = React.useRef({});
        const [centers, setCenters] = useState({});
        useEffect(() => {
          function calc() {
            const c = containerRef.current; if (!c) return;
            const crect = c.getBoundingClientRect();
            const next = {};
            for (const n of nodes) {
              const el = refs.current[n.id]; if (!el) continue;
              const r = el.getBoundingClientRect();
              next[n.id] = { x: r.left - crect.left + r.width/2, y: r.top - crect.top + r.height/2 };
            }
            setCenters(next);
          }
          calc();
          const ro = new ResizeObserver(calc);
          if (containerRef.current) ro.observe(containerRef.current);
          window.addEventListener("resize", calc);
          return () => { window.removeEventListener("resize", calc); ro.disconnect(); };
        }, [containerRef]);
        return { refs, centers };
      }

      /* ========== 補助UI：列の意味を薄い帯で表示 ========== */
      function ColumnBands() {
        const labels = ["入口/世界観","Phase 1","データ基盤","Phase 2 / 3","ブランド/コミュニティ"];
        return (
          <div className="absolute inset-0 pointer-events-none">
            {labels.map((label, i) => (
              <div key={i} className="absolute top-0 bottom-0" style={{
                left: `${(i * 100) / (GRID.COLS - 1)}%`,
                width: `${100 / (GRID.COLS - 1)}%`,
                transform: "translateX(-50%)",
              }}>
                <div className={cx("absolute inset-0", i % 2 === 0 ? "bg-slate-50" : "bg-white")} style={{ opacity: .6 }} />
                <div className="absolute left-1/2 -translate-x-1/2 top-2 text-[10px] px-2 py-1 bg-black/70 text-white rounded">{label}</div>
              </div>
            ))}
          </div>
        );
      }

      /* ========== カード ========== */
      function NodeCard({ n, register }) {
        const { left, top } = gridToPercent(n.grid.col, n.grid.row);
        return (
          <div
            ref={(el) => (register.current[n.id] = el)}
            className={cx("absolute w-[300px] max-w-[40vw] bg-white/95 backdrop-blur rounded-2xl shadow-lg ring-2", toneToRing[n.tone] || "ring-slate-300")}
            style={{ left: `${left}%`, top: `${top}%`, transform: "translate(-50%, -50%)" }}
          >
            <div className="p-4">
              <div className="text-xs tracking-widest opacity-70">{n.subtitle}</div>
              <div className="text-lg font-bold mt-0.5">{n.title}</div>
              <ul className="mt-2 space-y-1 text-sm leading-relaxed">
                {n.points.map((p, i) => (
                  <li key={i} className="flex gap-2 items-start">
                    <span className="mt-[6px] inline-block h-[6px] w-[6px] rounded-full bg-black/60" />
                    <span>{p}</span>
                  </li>
                ))}
              </ul>
            </div>
          </div>
        );
      }

      /* ========== 矢印レイヤー ========== */
      function ArrowLayer({ centers }) {
        const [size, setSize] = useState({ w: 0, h: 0 });
        const svgRef = useRef(null);
        useEffect(() => {
          const el = svgRef.current?.parentElement; if (!el) return;
          const onResize = () => { const r = el.getBoundingClientRect(); setSize({ w: r.width, h: r.height }); };
          onResize();
          const ro = new ResizeObserver(onResize); ro.observe(el);
          window.addEventListener("resize", onResize);
          return () => { window.removeEventListener("resize", onResize); ro.disconnect(); };
        }, []);
        const mid = (a,b) => ({ x:(a.x+b.x)/2, y:(a.y+b.y)/2 });

        return (
          <svg ref={svgRef} className="absolute inset-0 pointer-events-none" width={size.w} height={size.h}>
            <defs>
              {Object.entries(toneToStroke).map(([k, color]) => (
                <marker key={k} id={`arrow-${k}`} viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill={color} />
                </marker>
              ))}
            </defs>
            {edges.map((e, i) => {
              const a = centers[e.from], b = centers[e.to]; if (!a || !b) return null;
              const m = mid(a,b);
              const dx = b.x - a.x, dy = b.y - a.y;
              const normal = { x: -dy, y: dx }; const len = Math.hypot(normal.x, normal.y) || 1;
              const k = 0.08;
              const c1 = { x: a.x + dx*0.25 + (normal.x/len)*k*220, y: a.y + dy*0.25 + (normal.y/len)*k*220 };
              const c2 = { x: a.x + dx*0.75 + (normal.x/len)*k*220, y: a.y + dy*0.75 + (normal.y/len)*k*220 };
              return (
                <g key={i}>
                  <path d={`M ${a.x},${a.y} C ${c1.x},${c1.y} ${c2.x},${c2.y} ${b.x},${b.y}`} fill="none" stroke={toneToStroke[e.tone] || "#94a3b8"} strokeWidth={3} markerEnd={`url(#arrow-${e.tone})`} opacity={0.95} />
                  <foreignObject x={m.x - 90} y={m.y - 14} width={180} height={28}>
                    <div className="text-[10px] text-center bg-white/90 px-1 rounded-full border border-black/5">{e.label}</div>
                  </foreignObject>
                </g>
              );
            })}
          </svg>
        );
      }

      /* ========== 自前Pan/Zoomコンテナ（ホイール＆ドラッグ） ========== */
      function PanZoom({ children }) {
        const viewportRef = useRef(null);
        const contentRef = useRef(null);
        const [state, setState] = useState({ scale: 0.8, x: 0, y: 0, dragging: false, px: 0, py: 0 });
        const min = 0.4, max = 2.5;

        // ホイールでズーム（カーソル位置に寄せる）
        useEffect(() => {
          const el = viewportRef.current;
          function onWheel(e) {
            e.preventDefault();
            const rect = el.getBoundingClientRect();
            const cx = e.clientX - rect.left - state.x;
            const cy = e.clientY - rect.top - state.y;
            const delta = - (e.deltaY || e.wheelDelta) / 500; // ズーム量
            let ns = Math.min(max, Math.max(min, state.scale * (1 + delta)));
            const k = ns / state.scale;
            // ズーム中心を維持するようオフセットを調整
            const nx = state.x - (cx * (k - 1));
            const ny = state.y - (cy * (k - 1));
            setState(s => ({ ...s, scale: ns, x: nx, y: ny }));
          }
          el.addEventListener("wheel", onWheel, { passive: false });
          return () => el.removeEventListener("wheel", onWheel);
        }, [state.scale, state.x, state.y]);

        // ドラッグで移動
        function onMouseDown(e) { setState(s => ({ ...s, dragging: true, px: e.clientX, py: e.clientY })); }
        function onMouseMove(e) {
          if (!state.dragging) return;
          const dx = e.clientX - state.px;
          const dy = e.clientY - state.py;
          setState(s => ({ ...s, x: s.x + dx, y: s.y + dy, px: e.clientX, py: e.clientY }));
        }
        function onMouseUp() { setState(s => ({ ...s, dragging: false })); }

        return (
          <div
            ref={viewportRef}
            className="viewport relative overflow-hidden bg-white rounded-2xl border shadow-sm no-select"
            onMouseDown={onMouseDown}
            onMouseMove={onMouseMove}
            onMouseLeave={onMouseUp}
            onMouseUp={onMouseUp}
          >
            <div
              ref={contentRef}
              className="absolute"
              style={{
                width: "2000px",
                height: "1100px",
                transform: `translate(${state.x}px, ${state.y}px) scale(${state.scale})`,
                transformOrigin: "0 0"
              }}
            >
              {children}
            </div>
            <div className="absolute left-3 top-3 text-xs px-2 py-1 rounded-md bg-white/90 border shadow">ホイールでズーム / ドラッグで移動</div>
          </div>
        );
      }

      /* ========== 左パネル（任意表示） ========== */
      function SidePanel() {
        return (
          <div className="p-4 md:p-6 lg:p-8 h-full overflow-auto">
            <h1 className="text-2xl font-bold">採用3段階戦略のシナジーマップ（俯瞰）</h1>
            <p className="mt-2 text-sm leading-relaxed opacity-80">
              5カラム×7行の格子に固定。左→右で「入口→Phase1→データ基盤→Phase2/3→ブランド/コミュニティ」を追えます。
            </p>
            <div className="mt-3 text-xs bg-slate-50 border rounded-xl p-3">
              <div className="font-semibold mb-1">読み方のコツ</div>
              <ul className="list-disc pl-5 space-y-1">
                <li>縦は重要度/時間軸の微調整、横は流れの大筋</li>
                <li>中央「データ基盤」がハブ。上下（Phase2/3）と右端（ブランド/コミュニティ）へ循環</li>
                <li>矢印ラベルで関係性を即把握</li>
              </ul>
            </div>
          </div>
        );
      }

      /* ========== ルート ========== */
      function App() {
        const containerRef = useRef(null);
        const { refs, centers } = useNodePositions(containerRef);
        const [showPanel, setShowPanel] = useState(false); // 既定オフで広く表示

        return (
          <div className="w-full h-full bg-gradient-to-br from-slate-100 to-slate-50">
            <div className={cx("grid gap-4 p-4", showPanel ? "grid-cols-1 lg:grid-cols-[1.1fr_1.8fr]" : "grid-cols-1")}>
              {showPanel && (
                <aside className="rounded-2xl bg-white shadow-sm border overflow-hidden">
                  <SidePanel />
                </aside>
              )}

              <PanZoom>
                <div className="absolute inset-0" ref={containerRef}>
                  <ColumnBands />
                  <ArrowLayer centers={centers} />
                  {nodes.map((n) => <NodeCard key={n.id} n={n} register={refs} />)}
                  <div className="absolute left-4 top-4 text-xs px-2 py-1 bg-black/80 text-white rounded-md shadow">
                    HR版・循環する事業生態系（俯瞰レイアウト）
                  </div>
                </div>
              </PanZoom>

              <button
                onClick={() => setShowPanel(v => !v)}
                className="fixed z-10 left-3 bottom-3 text-xs px-3 py-1.5 rounded-md bg-white/90 border shadow hover:bg-white"
                title={showPanel ? "説明を隠す" : "説明を表示"}
              >
                {showPanel ? "説明を隠す" : "説明を表示"}
              </button>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
